package explain;

public class OOPTTest3 {

	public static void main(String[] args) {

		//타입이 다르기 때문에 일괄적으로 다룰 수 없다(경차와 세단은 다르다)
		//경차 경차1 = new 경차();
		//세단 세단1 = new 세단();
		
		//같은 타입으로 보고 배열로 다룰 수 있다
		//자동차 자동차1 = 경차1;
		//자동차 자동차2 = 세단1;
		
		//자동차[] 자동차들 = {자동차1, 자동차2};
		
		/*
		 
		for(int i = 0; i < 자동차들.length; i++) {
			자동차들[i].달리다();
		}// -> 출력하면 경차가 경쾌하게 달린다, 세단이 우아하게 달린다 ==> 경차는 달린다를 두개 가지고 있다(자신것 하나, 물려받은거 하나) 
		// -> 자신것을 우선적으로 사용하는것 == 오버라이딩
		
		똑같이 달리데 각자 다르게 달리게 하기 위해 오버라이딩 사용
		
		 */
		
		경차 경차1 = new 경차();
		세단 세단1 = new 세단();
		SUV SUV1 = new SUV();

		자동차 자동차1 = 경차1;
		자동차 자동차2 = 세단1;
		자동차 자동차3 = SUV1;

		자동차[] 자동차들 = { 자동차1, 자동차2, 자동차3 };

		for (int i = 0; i < 자동차들.length; i++) {
			자동차들[i].달리다();
		}

	}

}

/*
 지만 각각의 자동차가 자신만의 특성으원래 필요했로 달리기 때문에 사용이 안되기 때문에 필요가 없어졌다.
 class 자동차{
 	void 달리다(){
 	 	System.out.println("자동차가 달립니다.");
 	}
 }
 */


//껍데기만 필요하다(오버라이딩이될때 재정의 해주는 역할만 해주면 된다)
//달리다라는 버튼만 있으면 된다
//==> 자동차를 만들거면 달리다라는 개념을 각자 알아서 재정의 해라 강제 해버리는 단계
//내부구현은 알아서 해라, abstract ==> 추상적이다 실제 구현이 없는 메서드
abstract class 자동차 { // 추상 클래스(달리다라는 메서드에 내용이 없어서 자동차가 만들어질 수 없다 기능이 없기때문에 만들수 없다 -> abstract)
	abstract void 달리다(); // 구현이 없는 메서드 > 추상 메서드
}

class 경차 extends 자동차 {
	void 달리다() {
		System.out.println("경차가 경쾌하게 달립니다.");
	}

	void 연비절감() {
		System.out.println("연비가 절감됩니다.");
	}
}

class 세단 extends 자동차 {

	void 달리다() {
		System.out.println("세단이 우아하게 달립니다.");
	}

	void 안정된주행() {
		System.out.println("차가 정숙합니다.");
	}
}

class SUV extends 자동차 {
	
	//오버라이딩 사용을 위해서는 항상 상속과 이름이 같아야 사용 가능하다
	//달리다를 사용하지 않으면 에러가 뜬다 코드를 사용할 수 없다.
	void 달리다() {
		System.out.println("SUV가 힘차게 달립니다.");
	}

	void 많은적재() {
		System.out.println("짐을 많이 싣습니다.");
	}

}
